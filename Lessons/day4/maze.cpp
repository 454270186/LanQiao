#include <bits/stdc++.h>
#define maxn 10005
using namespace std;
string maze[30]= {
                  "01010101001011001001010110010110100100001000101010",
                  "00001000100000101010010000100000001001100110100101",
                  "01111011010010001000001101001011100011000000010000",
                  "01000000001010100011010000101000001010101011001011",
                  "00011111000000101000010010100010100000101100000000",
                  "11001000110101000010101100011010011010101011110111",
                  "00011011010101001001001010000001000101001110000000",
                  "10100000101000100110101010111110011000010000111010",
                  "00111000001010100001100010000001000101001100001001",
                  "11000110100001110010001001010101010101010001101000",
                  "00010000100100000101001010101110100010101010000101",
                  "11100100101001001000010000010101010100100100010100",
                  "00000010000000101011001111010001100000101010100011",
                  "10101010011100001000011000010110011110110100001000",
                  "10101010100001101010100101000010100000111011101001",
                  "10000000101100010000101100101101001011100000000100",
                  "10101001000000010100100001000100000100011110101001",
                  "00101001010101101001010100011010101101110000110101",
                  "11001010000100001100000010100101000001000111000010",
                  "00001000110000110101101000000100101001001000011101",
                  "10100101000101000000001110110010110101101010100001",
                  "00101000010000110101010000100010001001000100010101",
                  "10100001000110010001000010101001010101011111010010",
                  "00000100101000000110010100101001000001000000000010",
                  "11010000001001110111001001000011101001011011101000",
                  "00000110100010001000100000001000011101000000110011",
                  "10101000101000100010001111100010101001010000001000",
                  "10000010100101001010110000000100101010001011101000",
                  "00111100001000010000000110111000000001000000001011",
                  "10000001100111010111010001000110111010101101111000"};
int direct[4][2] = {{1,0},{0,-1},{0,1},{-1,0}};
bool vis[maxn][maxn];

struct node
{
    int x, y;
    char pos; // D, L, R, U
};

node father[maxn][maxn];
node cur_node;
node next_node;

void bfs(int x, int y) {
    queue<node> q;
    cur_node.x = x;
    cur_node.y = y;

    q.push(cur_node);

    father[x][y].x = 10000;
    father[x][y].y = 10000;
    father[x][y].pos = 0;

    vis[x][y] = true;
    while (!q.empty()) {
        cur_node = q.front();
        q.pop();

        for (int i = 0; i < 4; i++) {
            int tx = cur_node.x + direct[i][0];
            int ty = cur_node.y + direct[i][1];
            if (tx >= 0 && tx < 30 && ty >= 0 && ty < 50 && !vis[tx][ty] && maze[tx][ty] != '1') {
                vis[tx][ty] = true;
                next_node.x = tx;
                next_node.y = ty;
                q.push(next_node);
                
                father[tx][ty].x = cur_node.x;
                father[tx][ty].y = cur_node.y;
                

                if(i==0)
                    father[tx][ty].pos='D';
                else if(i==1)
                    father[tx][ty].pos='L';
                else if(i==2)
                    father[tx][ty].pos='R';
                else if(i==3)
                    father[tx][ty].pos='U';

            }
        }
    } 
}

void dfs(int x, int y) {
    if (x == 0 && y == 0) {
        return;
    } // 找到起点 准备回溯
    else {
        dfs(father[x][y].x, father[x][y].y);
    }

    cout << father[x][y].pos;
}

// bfs记录路径
// dfs回溯打印路径
int main() {
    bfs(0, 0);
    dfs(29, 49);
}